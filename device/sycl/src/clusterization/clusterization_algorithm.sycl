/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022-2024 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// Local include(s).
#include "../utils/get_queue.hpp"
#include "traccc/clusterization/device/ccl_kernel_definitions.hpp"
#include "traccc/sycl/clusterization/clusterization_algorithm.hpp"
#include "traccc/sycl/utils/barrier.hpp"

// Project include(s)
#include "traccc/clusterization/device/ccl_kernel.hpp"

// Vecmem include(s).
#include <vecmem/utils/sycl/local_accessor.hpp>

namespace traccc::sycl {

namespace kernels {

/// Class identifying the kernel running @c traccc::device::ccl_kernel
class ccl_kernel;

}  // namespace kernels

clusterization_algorithm::clusterization_algorithm(
    const traccc::memory_resource& mr, vecmem::copy& copy, queue_wrapper queue,
    const config_type& config)
    : m_mr(mr),
      m_queue(queue),
      m_copy(copy),
      m_config(config),
      m_f_backup(
          m_config.backup_partition_size * m_config.target_cells_per_partition,
          m_mr.main),
      m_gf_backup(
          m_config.backup_partition_size * m_config.target_cells_per_partition,
          m_mr.main),
      m_adjc_backup(
          m_config.backup_partition_size * m_config.target_cells_per_partition,
          m_mr.main),
      m_adjv_backup(m_config.backup_partition_size * 8 *
                        m_config.target_cells_per_partition,
                    m_mr.main),
      m_backup_mutex(vecmem::make_unique_alloc<unsigned int>(m_mr.main)) {
    unsigned int zero = 0;
    details::get_queue(m_queue)
        .memcpy(
            m_backup_mutex.get(), &zero,
            sizeof(
                std::remove_extent_t<decltype(m_backup_mutex)::element_type>))
        .wait_and_throw();
}

clusterization_algorithm::output_type clusterization_algorithm::operator()(
    const cell_collection_types::const_view& cells_view,
    const cell_module_collection_types::const_view& modules_view) const {

    // Get the number of cells
    const cell_collection_types::view::size_type num_cells =
        m_copy.get().get_size(cells_view);

    // Create the result object, overestimating the number of measurements.
    measurement_collection_types::buffer measurements{
        num_cells, m_mr.main, vecmem::data::buffer_type::resizable};
    m_copy.get().setup(measurements);
    measurement_collection_types::view measurements_view(measurements);

    // If there are no cells, return right away.
    if (num_cells == 0) {
        return measurements;
    }

    // Construct the kernel launch parameters.
    const device::details::ccl_kernel_helper helper{
        static_cast<device::details::index_t>(
            m_config.target_cells_per_partition),
        static_cast<device::details::index_t>(m_config.target_cells_per_thread),
        num_cells};
    ::sycl::nd_range cclKernelRange(
        ::sycl::range<1>(helper.num_partitions * helper.threads_per_partition),
        ::sycl::range<1>(helper.threads_per_partition));

    // Check if device is capable of allocating sufficient local memory
    assert(sizeof(device::details::index_t) * 2 *
                   helper.max_cells_per_partition +
               3 * sizeof(unsigned int) <
           details::get_queue(m_queue)
               .get_device()
               .get_info<::sycl::info::device::local_mem_size>());

    // Create buffer for linking cells to their measurements.
    //
    // @todo Construct cell clusters on demand in a member function for
    // debugging.
    //
    vecmem::data::vector_buffer<unsigned int> cell_links(num_cells, m_mr.main);
    m_copy.get().setup(cell_links)->wait();
    vecmem::data::vector_view<unsigned int> cell_links_view(cell_links);

    vecmem::data::vector_view<device::details::index_t> f_backup_view(
        m_f_backup);
    vecmem::data::vector_view<device::details::index_t> gf_backup_view(
        m_gf_backup);
    vecmem::data::vector_view<unsigned char> adjc_backup_view(m_adjc_backup);
    vecmem::data::vector_view<device::details::index_t> adjv_backup_view(
        m_adjv_backup);

    // Run ccl kernel
    details::get_queue(m_queue)
        .submit([&](::sycl::handler& h) {
            // Allocate shared memory for the kernel.
            vecmem::sycl::local_accessor<unsigned int> shared_uint(3, h);
            vecmem::sycl::local_accessor<device::details::index_t> shared_idx(
                2 * helper.max_cells_per_partition, h);

            // Launch the kernel.
            h.parallel_for<kernels::ccl_kernel>(
                cclKernelRange,
                [shared_uint, shared_idx, helper, cells_view, modules_view,
                 measurements_view, cell_links_view, f_backup_view,
                 gf_backup_view, adjc_backup_view, adjv_backup_view,
                 mutex_ptr = m_backup_mutex.get(),
                 cfg = m_config](::sycl::nd_item<1> item) {
                    // Construct more readable variable names.
                    vecmem::data::vector_view<device::details::index_t> f_view{
                        helper.max_cells_per_partition, &shared_idx[0]};
                    vecmem::data::vector_view<device::details::index_t> gf_view{
                        helper.max_cells_per_partition,
                        &shared_idx[helper.max_cells_per_partition]};
                    unsigned int& partition_start = shared_uint[0];
                    unsigned int& partition_end = shared_uint[1];
                    unsigned int& outi = shared_uint[2];

                    // Mutex for scratch space
                    vecmem::device_atomic_ref<unsigned int> backup_mutex(
                        *mutex_ptr);

                    // Barrier used in the algorithm.
                    traccc::sycl::barrier barry_r(item);

                    // Run the algorithm for this thread.
                    device::ccl_kernel(
                        item.get_local_linear_id(), item.get_local_range(0),
                        item.get_group_linear_id(), cells_view, modules_view,
                        helper.max_cells_per_partition,
                        cfg.target_cells_per_partition, partition_start,
                        partition_end, outi, f_view, gf_view, f_backup_view,
                        gf_backup_view, adjc_backup_view, adjv_backup_view,
                        backup_mutex, barry_r, measurements_view,
                        cell_links_view);
                });
        })
        .wait_and_throw();

    // Return the reconstructed measurements.
    return measurements;
}

}  // namespace traccc::sycl
